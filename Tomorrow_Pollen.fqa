{"name":"Tomorrow Pollen","type":"com.fibaro.genericDevice","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_831"},"sections":{"items":[{"components":[{"name":"label1","style":{"weight":"1.2"},"text":"Label","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_831"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"apiKey","value":"0"},{"name":"location","value":"0"},{"name":"interval","value":"3600"},{"name":"httpTimeout","value":"5"},{"name":"debugLevel","value":"1"},{"name":"icon","value":"0"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"-- QuickApp POLLEN (Tomorrow.io)\n\n-- This QuickApp gives access to real-time pollen count and risk category for grass pollen, weed pollen and tree pollen of any location from Tomorrow.io\n\n-- Pollen is a fine powder produced by trees and plants\n-- Pollen can severely affect people, especially those with different ailments such as asthma and respiratory issues.\n\n-- Grass Pollen: Pollen grains from grasses\n-- Weed Pollen: Weeds are annual and perennial herbs and shrubs. A single plant may produce about a billion grains of pollen per season. \n-- Tree Pollen: Pollen from trees such as Birch and Oak\n\n-- Risk:\n-- 0: None\n-- 1: Very low\n-- 2: Low\n-- 3: Medium\n-- 4: High\n-- 5: Very High\n\n\n-- IMPORTANT\n-- You need an API key from https://app.tomorrow.io\n-- The API is free up to 500 calls / per day, 25 calls / per hour, 3 calls / per second (Pollen is 5% of rate limit)\n-- You need to create your location in https://app.tomorrow.io/locations to get a location ID\n\n-- ToDo:\n-- Automatic retrieval of location ID from Tomorrow.io\n-- Further testing of measurements\n\n\n-- Version 0.1 (15th August 2021)\n-- Initial working version\n\n\n-- Variables (mandatory): \n-- apiKey = Get your free API key from Tomorrow.io\n-- location =  Tomorrow.io location ID (created in https://app.tomorrow.io/locations)\n-- interval = [number] in seconds time to get the data from the API\n-- timeout = [number] in seconds for http timeout\n-- debugLevel = Number (1=some, 2=few, 3=all, 4=simulation mode) (default = 1)\n-- icon = [numbber] User defined icon number (add the icon via an other device and lookup the number)\n\n\n-- No editing of this code is needed \n\n\nclass 'Grass'(QuickAppChild)\nfunction Grass:__init(dev)\n  QuickAppChild.__init(self,dev)\n  --self:trace(\"Grass initiated, deviceId:\",self.id)\nend\nfunction Grass:updateValue(data) \n  self:updateProperty(\"value\",tonumber(data.ValueGrass))\n  self:updateProperty(\"unit\", \"\")\n  self:updateProperty(\"log\", data.RiskGrass)\nend\n\nclass 'Weed'(QuickAppChild)\nfunction Weed:__init(dev)\n  QuickAppChild.__init(self,dev)\n  --self:trace(\"Weed initiated, deviceId:\",self.id)\nend\nfunction Weed:updateValue(data) \n  self:updateProperty(\"value\",tonumber(data.ValueWeed)) \n  self:updateProperty(\"unit\", \"\")\n  self:updateProperty(\"log\", data.RiskWeed)\nend\n\nclass 'Tree'(QuickAppChild)\nfunction Tree:__init(dev)\n  QuickAppChild.__init(self,dev)\n  --self:trace(\"Tree initiated, deviceId:\",self.id)\nend\nfunction Tree:updateValue(data) \n  self:updateProperty(\"value\",tonumber(data.ValueTree)) \n  self:updateProperty(\"unit\", \"\")\n  self:updateProperty(\"log\", data.RiskTree)\nend\n\n\n-- QuickApp functions\n\n\nlocal function getChildVariable(child,varName)\n  for _,v in ipairs(child.properties.quickAppVariables or {}) do\n    if v.name==varName then return v.value end\n  end\n  return \"\"\nend\n\n\nfunction QuickApp:logging(level,text) -- Logging function for debug\n  if tonumber(debugLevel) >= tonumber(level) then \n      self:debug(text)\n  end\nend\n\n\nfunction QuickApp:updateProperties() --Update properties\n  self:logging(3,\"updateProperties\")\n  self:updateProperty(\"log\", data.startTime)\nend\n\n\nfunction QuickApp:updateLabels() -- Update labels\n  self:logging(3,\"updateLabels\")\n  local labelText = \"\"\n  if debugLevel == 4 then\n    labelText = labelText ..\"SIMULATION MODE\" ..\"\\n\\n\"\n  end\n  labelText = labelText ..\"Grass Pollen: \" ..data.ValueGrass ..\" (\" ..data.RiskGrass ..\")\" ..\"\\n\"\n  labelText = labelText ..\"Weed Pollen: \" ..data.ValueWeed ..\" (\" ..data.RiskWeed ..\")\" ..\"\\n\"\n  labelText = labelText ..\"Tree Pollen:  \" ..data.ValueTree ..\" (\" ..data.RiskTree ..\")\" ..\"\\n\\n\"\n\n  labelText = labelText ..\"Measured: \" ..data.startTime ..\"\\n\"\n\n  self:logging(2,\"labelText: \" ..labelText)\n  self:updateView(\"label1\", \"text\", labelText) \nend\n\n\nfunction QuickApp:setRisk(val) -- Set the risk indication\n  self:logging(3,\"setRisk\")\n  \n  if val == 0 then\n    return \"No risk\"\n  elseif val == 1 then\n    return \"Very low risk\"\n  elseif val == 2 then\n    return \"Low risk\"\n  elseif val == 3 then\n    return \"Medium risk\"\n  elseif val == 4 then\n    return \"High risk\"\n  elseif val == 5 then\n    return \"Very high risk\"\n  else\n    return \"\"\n  end\nend\n\n\nfunction QuickApp:getValues() -- Get the values\n  self:logging(3,\"getValues\")\n  \n  data.startTime = jsonTable.data.timelines[1].startTime\n  data.ValueGrass = jsonTable.data.timelines[1].intervals[1].values.grassIndex\n  data.ValueWeed = jsonTable.data.timelines[1].intervals[1].values.weedIndex\n  data.ValueTree = jsonTable.data.timelines[1].intervals[1].values.treeIndex\n  \n  data.RiskGrass = self:setRisk(tonumber(data.ValueGrass))\n  data.RiskWeed = self:setRisk(tonumber(data.ValueWeed))\n  data.RiskTree = self:setRisk(tonumber(data.ValueTree))\n\n  -- Check timezone and daylight saving time\n  local timezone = os.difftime(os.time(), os.time(os.date(\"!*t\",os.time())))/3600\n  if os.date(\"*t\").isdst then -- Check daylight saving time \n    timezone = timezone + 1\n  end\n  self:logging(3,\"Timezone + dst: \" ..timezone)\n\n  -- Convert time of measurement to local timezone\n  local pattern = \"(%d+)-(%d+)-(%d+) (%d+):(%d+):(%d+)\"\n  data.startTime = data.startTime:gsub(\"%.000Z\", \"\") -- Clean up date/time\n  data.startTime = data.startTime:gsub(\"%T\", \" \") -- Clean up date/time\n  local runyear, runmonth, runday, runhour, runminute, runseconds = data.startTime:match(pattern)\n  local convertedTimestamp = os.time({year = runyear, month = runmonth, day = runday, hour = runhour, min = runminute, sec = runseconds})\n  data.startTime = os.date(\"%d-%m-%Y %X\", convertedTimestamp + (timezone*3600))\nend\n\n\nfunction QuickApp:checkLocation() -- Get the location ID from Tomorrow.io\n  self:logging(3,\"Start checkLocation\")\n  \n  local url = \"https://api.tomorrow.io/v4/locations?apikey=\" ..apiKey\n  self:logging(2,\"URL: \" ..url)\n\n  http:request(url, {\n    options = {data = Method, method = \"GET\", headers = {[\"Content-Type\"] = \"application/json\",[\"Accept\"] = \"application/json\",}},\n    \n      success = function(response)\n        self:logging(3,\"response status: \" ..response.status)\n        self:logging(3,\"headers: \" ..response.headers[\"Content-Type\"])\n        self:logging(2,\"Response data: \" ..response.data)\n\n        if response.data == nil or response.data == \"\" or response.data == \"[]\" or response.status > 200 then -- Check for empty result\n          self:warning(\"Temporarily no location from Tomorrow.io, setting default location\")\n          self:warning(response.data)\n          location = \"61137ec8533a7e0008b53f4d\" -- Default location \"De Bilt\"\n          return\n        end\n\n        local geoTable = json.decode(response.data) -- JSON decode from api to lua-table\n        location = tostring(geoTable.data.locations[1].id) -- Get the FIRST location ID from Tomorrow.io\n        self:logging(3, \"location: \" ..location)\n      \n      end,\n      error = function(error)\n        self:error('error: ' ..json.encode(error))\n        self:updateProperty(\"log\", \"error: \" ..json.encode(error))\n      end\n    }) \n  self:logging(3,\"location: \" ..location)\n  self:setVariable(\"location\", location)\n  self:trace(\"Added QuickApp variable location: \" ..location)\nend\n\n\nfunction QuickApp:simData() -- Simulate Tomorrow.io API\n  self:logging(3,\"Simulation mode\")\n  local apiResult = '{\"data\":{\"timelines\":[{\"timestep\":\"current\",\"startTime\":\"2021-08-11T07:08:00Z\",\"endTime\":\"2021-08-11T07:08:00Z\",\"intervals\":[{\"startTime\":\"2021-08-11T07:08:00Z\",\"values\":{\"weedIndex\":1,\"treeIndex\":2,\"grassIndex\":3}}]}]}}'\n  \n  self:logging(3,\"apiResult: \" ..apiResult)\n\n  jsonTable = json.decode(apiResult) -- Decode the json string from api to lua-table \n  \n  self:getValues()\n  self:updateLabels()\n  self:updateProperties()\n\n  for id,child in pairs(self.childDevices) do \n    child:updateValue(data) \n  end\n  \n  self:logging(3,\"SetTimeout \" ..interval ..\" seconds\")\n  fibaro.setTimeout(interval*1000, function() \n     self:simData()\n  end)\nend\n\n\nfunction QuickApp:getData()\n  self:logging(3,\"Start getData\")\n  \n  --if location == \"\" or location == \"0\" or location == nil then \n    --self:checkLocation() -- Check your location ID from Tomorrow.io\n  --end\n  \n  self:logging(2,\"URL: \" ..address)\n    \n  http:request(address, {\n    options = {data = Method, method = \"GET\", headers = {[\"Content-Type\"] = \"application/json\",[\"Accept\"] = \"application/json\",}},\n    \n      success = function(response)\n        self:logging(3,\"response status: \" ..response.status)\n        self:logging(3,\"headers: \" ..response.headers[\"Content-Type\"])\n        self:logging(2,\"Response data: \" ..response.data)\n\n        if response.data == nil or response.data == \"\" or response.data == \"[]\" or response.status > 200 then -- Check for empty result\n          self:warning(\"Temporarily no data from Tomorrow.io\")\n          self:warning(response.data)\n          return\n        end\n\n        jsonTable = json.decode(response.data) -- JSON decode from api to lua-table\n\n        self:getValues()\n        self:updateLabels()\n        self:updateProperties()\n\n        for id,child in pairs(self.childDevices) do \n          child:updateValue(data) \n        end\n      \n      end,\n      error = function(error)\n        self:error('error: ' ..json.encode(error))\n        self:updateProperty(\"log\", \"error: \" ..json.encode(error))\n      end\n    }) \n\n  self:logging(3,\"SetTimeout \" ..interval ..\" seconds\")\n  fibaro.setTimeout((interval)*1000, function() \n     self:getData()\n  end)\nend\n\n\nfunction QuickApp:createVariables() -- Get all Quickapp Variables or create them\n  data = {}\n  data.startTime = \"\"\n  data.ValueGrass = \"0\"\n  data.ValueWeed = \"0\"\n  data.ValueTree = \"0\"\n  data.RiskGrass = \"\"\n  data.RiskWeed = \"\"\n  data.RiskTree = \"\"\nend\n\n\nfunction QuickApp:getQuickAppVariables() -- Get all variables \n  apiKey = self:getVariable(\"apiKey\")\n  location = self:getVariable(\"location\")\n  interval = tonumber(self:getVariable(\"interval\")) \n  httpTimeout = tonumber(self:getVariable(\"httpTimeout\")) \n  debugLevel = tonumber(self:getVariable(\"debugLevel\"))\n  local icon = tonumber(self:getVariable(\"icon\")) \n\n  if apiKey == \"\" or apiKey == \"0\" or apiKey == nil then\n    apiKey = \"0\" \n    self:setVariable(\"apiKey\",apiKey)\n    self:trace(\"Added QuickApp variable apiKey\")\n  end\n  if location == \"\" or location == \"0\" or location == nil then\n    location = \"0\" \n    self:setVariable(\"location\",location)\n    self:trace(\"Added QuickApp variable location\")\n  end\n  if interval == \"\" or interval == nil then\n    interval = \"3600\" -- (every 60 minutes)\n    self:setVariable(\"interval\",interval)\n    self:trace(\"Added QuickApp variable interval: \" ..interval)\n    interval = tonumber(interval)\n  end  \n  if httpTimeout == \"\" or httpTimeout == nil then\n    httpTimeout = \"5\" -- timeoout in seconds\n    self:setVariable(\"httpTimeout\",httpTimeout)\n    self:trace(\"Added QuickApp variable httpTimeout\")\n    httpTimeout = tonumber(httpTimeout)\n  end\n  if debugLevel == \"\" or debugLevel == nil then\n    debugLevel = \"1\" -- Default value for debugLevel response in seconds\n    self:setVariable(\"debugLevel\",debugLevel)\n    self:trace(\"Added QuickApp variable debugLevel\")\n    debugLevel = tonumber(debugLevel)\n  end\n  if icon == \"\" or icon == nil then \n    icon = \"0\" -- Default icon\n    self:setVariable(\"icon\",icon)\n    self:trace(\"Added QuickApp variable icon\")\n    icon = tonumber(icon)\n  end\n  if icon ~= 0 then \n    self:updateProperty(\"deviceIcon\", icon) -- set user defined icon \n  end\n  \n  address = \"https://api.tomorrow.io/v4/timelines?location=\" ..location ..\"&fields=weedIndex&fields=treeIndex&fields=grassIndex&units=metric&timesteps=current&apikey=\" ..apiKey\n\n  if apiKey == nil or apiKey == \"\"  or apiKey == \"0\" then -- Check mandatory API key \n    self:error(\"API key is empty! Get your free API key from Tomorrow.io\")\n    self:warning(\"No API Key: Switched to Simulation Mode\")\n    debugLevel = 4 -- Simulation mode due to empty API key\n  end\n  \n  if location == nil or location == \"\"  or location == \"0\" then -- Check mandatory location   \n    self:error(\"Location ID is empty! Create your location at your account on Tomorrow.io and copy the location ID to the quickapp variable\")\n    self:warning(\"No location: Switched to Simulation Mode\")\n    debugLevel = 4 -- Simulation mode due to empty location \n  end\n\nend\n\n\nfunction QuickApp:setupChildDevices()\n  local cdevs = api.get(\"/devices?parentId=\"..self.id) or {} -- Pick up all my children \n  function self:initChildDevices() end -- Null function, else Fibaro calls it after onInit()...\n\n  if #cdevs==0 then -- No children, create children\n    local initChildData = { \n      {className=\"Grass\", name=\"Grass\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"Weed\", name=\"Weed\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"Tree\", name=\"Tree\", type=\"com.fibaro.multilevelSensor\", value=0},\n    }\n    for _,c in ipairs(initChildData) do\n      local child = self:createChildDevice(\n        {name = c.name,\n          type=c.type,\n          value=c.value,\n          unit=c.unit,\n          initialInterfaces = {}, \n        },\n        _G[c.className] -- Fetch class constructor from class name\n      )\n      child:setVariable(\"className\",c.className)  -- Save class name so we know when we load it next time\n    end   \n  else \n    for _,child in ipairs(cdevs) do\n      local className = getChildVariable(child,\"className\") -- Fetch child class name\n      local childObject = _G[className](child) -- Create child object from the constructor name\n      self.childDevices[child.id]=childObject\n      childObject.parent = self -- Setup parent link to device controller \n    end\n  end\nend\n\n\nfunction QuickApp:onInit()\n  __TAG = fibaro.getName(plugin.mainDeviceId) ..\" ID:\" ..plugin.mainDeviceId\n  self:debug(\"onInit\") \n  \n  self:setupChildDevices() -- Setup the Child Devices\n  self:getQuickAppVariables() -- Get Quickapp Variables or create them\n  self:createVariables() -- Create Variables\n  \n  http = net.HTTPClient({timeout=httpTimeout*1000})\n\n  if tonumber(debugLevel) >= 4 then \n    self:simData() -- Go in simulation\n  else\n    self:getData() -- Get data from API\n  end\nend\n\n--EOF"}]}